<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Fabián Sanabria-Mora">

<title>time_s</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="time_s_files/libs/clipboard/clipboard.min.js"></script>
<script src="time_s_files/libs/quarto-html/quarto.js"></script>
<script src="time_s_files/libs/quarto-html/popper.min.js"></script>
<script src="time_s_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="time_s_files/libs/quarto-html/anchor.min.js"></script>
<link href="time_s_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="time_s_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="time_s_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="time_s_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="time_s_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">time_s</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Fabián Sanabria-Mora </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="series-de-tiempo" class="level1">
<h1>Series de tiempo</h1>
<section id="repaso-de-r" class="level2">
<h2 class="anchored" data-anchor-id="repaso-de-r">Repaso de R</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>ex <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(ex)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    2.0     3.5     5.0     5.0     6.5     8.0 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(ex)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sd</span>(ex)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2.581989</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(ex)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="time_s_files/figure-html/funciones%20de%20repaso-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="do">### xlab = "" / nombre del eje x</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="do">### main = "" / título del histograma</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="do">### freq = FALSE / muestra densidad (probabilidades)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="do">### breaks = 10 / ancho de los rectángulos del histograma</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">density</span>(<span class="fu">c</span>(<span class="sc">-</span><span class="dv">20</span>, <span class="fu">rep</span>(<span class="dv">0</span>,<span class="dv">98</span>), <span class="dv">20</span>)), <span class="at">xlim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">4</span>, <span class="dv">4</span>), <span class="at">col =</span> <span class="st">"royalblue"</span>, <span class="at">lwd =</span> <span class="dv">3</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="time_s_files/figure-html/funciones%20de%20repaso-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="do">### con línea de densidad</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="do">### También aplican las funciones: main, xlab, ylab, col</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A continuación se presentan algunos enlaces de documentos base del curso:</p>
<p><a href="https://1drv.ms/b/s!AjFqM4QxCQqRtF-brELYLGsEPcsu?e=J13LP2" title="Basic statistics">Basic statistics</a></p>
<p><a href="https://1drv.ms/b/s!AjFqM4QxCQqRtGDUn4Jll1oQc3c1?e=Ysqpbh" title="Correlation">Correlation</a></p>
<p><a href="https://1drv.ms/b/s!AjFqM4QxCQqRtGJV0wbPd4bhj6eL?e=4arVTv" title="Quiz1">Quiz1</a></p>
</section>
<section id="conceptos-básicos-de-series-de-tiempo" class="level2">
<h2 class="anchored" data-anchor-id="conceptos-básicos-de-series-de-tiempo">Conceptos básicos de series de tiempo</h2>
<p><strong>Una serie de tiempo es cualquier conjunto de datos recogidos en diferentes momentos</strong>. El análisis de los datos observados en diferentes puntos de tiempo lleva a problemas únicos que no cubre la estadística clásica. La <strong>dependencia</strong> introducida por el muestreo de datos a lo largo del tiempo restringe la aplicabilidad de muchos métodos estadísticos convencionales. El análisis de este tipo de datos se conoce como <strong>ANÁLISIS DE SERIES DE TIEMPO</strong>.</p>
<p>Los datos se representan como una <u>colección de variables aleatorias indexadas de acuerdo al orden en que se obtienen en el tiempo</u>. Por ejemplo, la temperatura diaria de una ciudad se puede representar mediante una secuencia de variables aleatorias <code>x1, x2, x3</code>, en donde <code>x1</code> es la T del día 1, <code>x2</code> la del día 2, y así sucesivamente. En general, <strong>una colección de variables aleatorias indexadas por un <em>t</em> se conoce como un proceso estocástico</strong>.</p>
<p>El objetivo primario de un análisis de series de tiempo es desarrollar modelos matemáticos que proveen descripciones plausibles a la muestra de datos.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(astsa)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Cargando paquete requerido: astsa</code></pre>
</div>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(jj, <span class="at">type =</span> <span class="st">"o"</span>, <span class="at">main =</span> <span class="st">"JJ quarterly earnings per share"</span>, <span class="at">ylab =</span> <span class="st">"earnings"</span>, <span class="at">xlab =</span> <span class="st">"quarters"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="time_s_files/figure-html/ejemplo-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># jj ya se encuentra en formato de serie de tiempo, por lo que no se requiere el operador ts()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En esta gráfica se puede ver una clara tendencia al aumento, no obstante, también se pueden diferenciar las fluctuaciones, <strong>las variaciones estacionales de esa tendencia. Es importante anotar que al principio la variación era MÍNIMA, y luego fue aumentando</strong>, es decir, hay cambios en la variación → <strong>se viola el principio de estacionariedad</strong>.</p>
<p>Otro ejemplo: <em>flu</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(flu, <span class="at">type =</span> <span class="st">"o"</span>, <span class="at">main =</span> <span class="st">"Monthly pneumonia and influenza deaths in US"</span>, <span class="at">ylab =</span> <span class="st">"Number of deaths per 10.000 people"</span>, <span class="at">xlab =</span> <span class="st">"Months"</span>, <span class="at">col =</span> <span class="st">"royalblue1"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="time_s_files/figure-html/otro%20ejemplo-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>En esta gráfica hay <strong>estacionalidad</strong>, hay un pico cada dos años, más o menos, y la tendencia pareciera ir hacia la disminución (es más difícil de ver).</p>
<p><strong>Cuando hay estacionalidad NO hay estacionariedad</strong>.</p>
<section id="función-de-la-media" class="level3">
<h3 class="anchored" data-anchor-id="función-de-la-media">Función de la media</h3>
<p><span class="math inline">\(\mu_{xt} = E(X_t)\)</span></p>
<p><em>E</em> denota el valor esperado usual. Ej.: media mensual de la temperatura de una ciudad. En este caso, <strong>la media es una función del tiempo</strong>. La función de la media describe solo el comportamiento marginal de una serie de tiempo.</p>
</section>
<section id="función-de-autocovarianza" class="level3">
<h3 class="anchored" data-anchor-id="función-de-autocovarianza">Función de autocovarianza</h3>
<p><strong>Una variable aleatoria es una función que va del espacio muestral (S) a los números reales. “Es una máquina que produce números aleatorios”</strong>.</p>
<p><span class="math inline">\(X: S → R\)</span></p>
<p>En la medida que esta máquina produce diferentes números aleatorios, dichos números van formando un <strong>conjunto de datos</strong>. Si se conocen las características de la variable aleatoria, por ejemplo, su distribución, se puede decir algo significativo sobre el conjunto de datos.</p>
<p>Una variable aleatoria puede ser discreta o continua. Ej.: sea <span class="math inline">\(X = [20, 37, 57, …]\)</span></p>
<p>Entonces <em>X</em> es una variable aleatoria que puede tomar cualquiera de esos valores. Una vez se conoce el resultado, por ejemplo, <em>X = 20</em>, <strong>desaparece la aleatoriedad</strong>. Se dice que 20 es una <strong>REALIZACIÓN DE LA VARIABLE ALEATORIA X</strong>.</p>
<p>De igual manera aplica para una variable aleatoria continua.</p>
<p><strong>Covarianza:</strong> mide la dependencia lineal entre dos variables aleatorias <em>(X, Y)</em>.</p>
<p><span class="math inline">\(Cov(X,Y) = E[(X-\mu X)(Y-\mu Y)] = Cov(Y,X)\)</span></p>
<p><strong>Proceso estocástico</strong>: colección / secuencia de variables aleatorias. Es lo contrario a un proceso determinista, ya que, en un proceso estocástico, en cada paso se tiene algo de aleatoriedad.</p>
<p><span class="math inline">\(X_1, X_2, X_3,...\)</span></p>
<p><span class="math inline">\(X_t \sim distibution(\mu,\sigma^2)\)</span></p>
<p>Cada variable puede tener su propia distribución, sus propios valores esperados y varianzas, sin embargo, no es posible saber <em>“en dónde se va a estar”</em>, como si lo es en un proceso determinístico.</p>
<p><strong>Una serie de tiempo es la realización de un proceso estocástico</strong> → <span class="math inline">\(X_1\)</span> es el primer punto de datos en la serie de tiempo, <span class="math inline">\(X_2\)</span> el segundo, y así sucesivamente… entonces se conoce la realización de cada punto, <strong>la realización del proceso estocástico que va por detrás</strong>. Y si se conoce cada <span class="math inline">\(X_1, X_2, X_3\)</span>, y cómo cambian, se puede decir algo significativo sobre la serie.</p>
<p><strong>La función de autocovarianza se define como el producto del segundo momento (varianza) para todos los <em>s</em> y <em>t</em>.</strong> Se toma la covarianza de diferentes elementos de la secuencia (del proceso estocástico). <u>La autocovarianza mide la dependencia lineal entre dos puntos de una misma serie observados en diferentes tiempos</u>.</p>
<p><span class="math inline">\(\gamma(s,t) = Cov(X_s,X_t) = E[(X_s-\mu_s)(X_t-\mu_t)]\)</span></p>
<p>Esta fórmula indica que se está calculando la covarianza entre las variables aleatorias en los puntos específicos <em>s</em> y <em>t</em>. Si <span class="math inline">\(s=t\)</span>, la autocovarianza se reduce a la varianza:</p>
<p><span class="math inline">\(\gamma(t,t) = E[(X_t-\mu_t)^2] = Var(X_t) = \sigma_t^2\)</span></p>
<p>Recordar que:</p>
<p>Si <span class="math inline">\(\gamma_x(s,t) = 0\)</span>, entonces <span class="math inline">\(X_s\)</span> y <span class="math inline">\(X_t\)</span> no están linealmente relacionados, sin embargo, podría existir alguna dependencia entre ellos.</p>
<p>Ahora, <span class="math inline">\(\gamma_k = \gamma(t,t + k) \approx C_k\)</span></p>
<p>Esta fórmula indica que se está calculando la covarianza entre las variables aleatorias en los puntos específicos <em>t</em> y <em>t + k</em>. <strong>Esta función de autocovarianza <span class="math inline">\(\gamma_k\)</span> en el tiempo <em>k</em> solo dependerá de la diferencia de tiempo <em>(k)</em> entre las variables aleatorias</strong>, esta diferencia de tiempo es la que decide el destino de la autocovarianza. La razón de ello es que se asume que se está trabajando con series de tiempo estacionarias, en donde una parte de la serie temporal tiene las mismas propiedades que las demás partes.</p>
<p>El hecho de que se tenga la serie de tiempo como una realización de un proceso estocástico, permite aproximar la función de autocovarianza al coeficiente de autocovarianza <span class="math inline">\(C_k\)</span></p>
</section>
<section id="función-de-autocorrelación-acf" class="level3">
<h3 class="anchored" data-anchor-id="función-de-autocorrelación-acf">Función de autocorrelación (ACF)</h3>
</section>
<section id="estacionariedad" class="level3">
<h3 class="anchored" data-anchor-id="estacionariedad">Estacionariedad</h3>
<p>Lo que se quiere es que una serie de tiempo sea estacionaria, que no haya ningún cambio sistemático en sus propiedades y comportamiento.</p>
<ul>
<li>No se quieren ver cambios en la media.</li>
<li>No se quiere ver una tendencia en una serie temporal estacionaria.</li>
<li>No se quieren cambios sistemáticos en la variación.<br>
</li>
<li>No se quieren fluctuaciones periódicas.</li>
</ul>
<p><strong>Lo que se quiere es que las propiedades de una sección de los datos sean muy parecidas a las propiedades de las otras secciones.</strong></p>
<p>La estacionariedad es una propiedad de un proceso estocástico de un modelo, no de una serie temporal en sí, pero se habla de serie temporal estacionaria si se piensa que se puede modelar mediante modelos estacionarios <strong>(procesos estocásticos estacionarios)</strong>.</p>
<p>Se suelen tener series de tiempo NO estacionarias, por lo que hay que hacer TRANSFORMACIONES para volverlas estacionarias.</p>
</section>
<section id="estacionalidad" class="level3">
<h3 class="anchored" data-anchor-id="estacionalidad">Estacionalidad</h3>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>